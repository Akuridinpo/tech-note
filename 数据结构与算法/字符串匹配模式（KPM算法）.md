
## 传统暴力解法：
字符串的一一匹配。
1. 主串第 i 个字符比较子串第 j 个字符
2. 如果相同
	1. 主串子串指针一起后移，重复比较第 i+1 与 j+1, 个字符
	2. 如果循环结束仍然相同
		1. 主串指针回溯至刚开始匹配比较的下标后返回下标
	3. 如果中间有不同
		1. 子串指针 j 返回 0 ，主串指针 i 回溯至刚开始匹配比较的下标再+1
3. 返回重新比较。
4. 全部比较完仍然没有成功完全匹配，则返回-1，表示没有匹配的字符串。


## KMP 解法
### KMP 对传统暴力解法的改进思路 ：
	主串指针 i 不需要每次都回溯到 i-j 的位置，而是一直向前推进。
	子串指针 j 不需要每次重置为 0
	以此节省比较次数。
	
通过数学证明发现：
	可以让子串指针 i 每次回溯至==**当前指向的子串位置向前，字符串前缀与后缀的最长匹配长度 + 1**==, 同样可以完成比较。


主串

| `a` | `b` | `a` | `b` | `a` | `b` | `c` | `a` |
| --- | --- | --- | --- | --- | --- | --- | --- |
子串

| `a` | `b` | `a` | `b` | `c` |
| --- | --- | --- | --- | --- |
| 0   | 0   | 1   | 2   | 0   |
当比较到 `p[4]` 时，发现最后一个字符不匹配，此时不需要让主串的指针 i=4 回溯，而是将子串指针回溯到 j= `a b a b` 的前后缀最长匹配串长度 2 处，在 `[i=4, j=2]` 的情况下继续往后进行匹配即可。
### KMP 的关键点：
	求得一个数组 `next[]`，其长度为子串的长度。
	其中：
		每当子串与主串失配时，主串回溯至匹配开始的下标+1 的位置(i - j)。
		子串回溯至 `next[j]` 的位置。
		
#### <font color = green>next[]数组的实现逻辑</font>
通过递推的方法求得对前后缀最长匹配串长度。
	首先，我们将数组 `next[]` 的长度设为子串 p 的长度 5。
	然后，我们需要两个指针 `i , j` 分别为后缀指针与前缀指针。
	在 i = 0 时，单一字符并没有前后缀，于是 `next[0] = 0 `
	
	所以后缀指针i从i=1处开始遍历。
	前缀指针j从0处开始。
		 判断p[i]==p[j]?
			 如果不相等，且j>0,
			 则不停在next[]数组中回溯 j = next[j - 1]，直至找到p[i]==p[j]相等的
			 位置或者j=0。
		 如果相等，则j++;
		 next[i]=j
	

	
	<Eg.>字符串 `ababc` 的前缀数组 `next[]`
	
	i = 1
	此时，j 不大于 0 ，且
	p[j]=p[0]=a 不等于 p[i]=p[1]=b
	所以在i=1,j=0的串ab中，不存在匹配前后缀
	所以next[1] = 0;
	next={0,0,?,?,?}

	i = 2
	此时，j仍然不大于0，
	但p[j]=a 等于 p[i]=a
	证明此时有匹配串，长度为j+1=1;
	所以next[2] = 1;
	next={0,0,1,?,?}
	

	i = 3，j = 1
	此时，j > 0,且p[j]=p[1]=b 等于 p[i]=p[3]=b
	证明此时前后缀又多了一个匹配字符，最长前后缀匹配串的长度+1
	所以next[3]= j + 1 = 2;
	next={0,0,1,2,?}

	i = 4,j = 2
	此时j > 0,且p[j]=p[2]=a 不等于 p[i]=p[4]=c
	

| `a` | `b` | `a` | `b` | `c` |
| --- | --- | --- | --- | --- |
| 0   | 0   | 1   | 2   | ？   |
	此时，我们需要让指针 j 回溯，回溯代码是 `j = next[j-1]`
	在当前情况下，`j = next[1] = 0` 
	我们可以将其等效看为，子串 p 中的更小子串 `p[0:1]`，也就是 `a b` 的最长匹配串长度是 0，
	也就是说我们在检查 `a b a b ` + `c` 的情况，等同于在检查 `a b` + `c` 的情况。
	
	j 不大于 0，且 p[j]=p[0]=a 不等于 p[i]=p[4]=c
	所以 next[4]=0
	
	于是得出，该next[]数组为{0, 0, 1, 2, 0}


