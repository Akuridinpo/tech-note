# 查找

## 查找类型

### 静态查找

数据稳定，一般查找线性表。

乱序数组，只能一一比较。所以需要排序。

### 动态查找

查找的过程中增删元素。

一般使用二叉排序树，排序树的增加节点出现在叶子节点。

有时使用散列表。

### 内查找

内存中查找，速度快。

### 外查找

外存中查找，速度慢。

### 平均查找长度

平均需要和待查找关键字进行比较的次数

## 查找算法

###  顺序查找（线性查找）

循环遍历，一对一查找。

对于乱序定长数据，使用把常用的数据放在数据前，可节省查找资源。

### 折半查找（二分查找）

对于有序定长数据

1. 设置两个指针，一个指向头部，一个指向尾部。

2. 计算一个中间指针（向下取整）

3. 将待查找值，与中间指针比较。

4. 比较出的结果如果：

   ①数据等于中间指针的值，完成查找。

   ②数据小于中间指针的值，将指向尾部的指针指向中间指针的前一个位置，重复计算中间指针并继续查找，直至数据都等于中间指针为止。

   ③数据大于中间指针的值，将指向头部的指针指向中间指针的后一个位置，重复计算中间指针并继续查找，直至数据都等于中间指针为止。

适合顺序表（数组）。在使用

​                                

### 分块查找

用于索引存储结构（存在索引表）。

将查找表分为若干模块，块内元素可以无序，但是块与块间有序。

先对索引进行查找，再对索引内元素进行查找。

### 跳跃查找

用于有序定长数据，以步长向后跳，尽可能跳过更多不在查找范围内的数据，用于减少比较次数。

跳跃查找的优势：成本低于二分查找，跳跃查找只需要回溯一次。

例如一个有 `16` 个数据的数组，将步长设置为 `sqrt(16)// 4`。

1. 设置两个指针，前指针指向头部，后指针指向前指针+步长的位置。
2. 将待查找元素与后指针的前一个元素比较，若待查找元素大于后指针的前一个元素，则将前指针指向后指针，将后指针指向后指针+步长的位置。
3. 重复比较直至发现待查元素小于后指针的前一个元素，从前指针开始遍历至后指针来查找待查元素。

### 插值查找

用于有序且均匀分布的定长数据，与二分查找大致相同，但是找中间点的公式不同。

公式：`mid = low + ( (待查元素 - arr[low])/(arr[high] - arr[low]) )(high - low)`

当待查元素靠近高位指针，则求出的 `mid` 指针也靠近高位指针（低位同理）。

### 斐波那契查找 (黄金分割比查找)

随着斐波那契数列的增加，其后一位与前一位的比值越来越趋近 0.618 (黄金分割比)。

用于有序定长的数据。

1. 获得数据总量，在斐波那契数列中找一个大于等于数据总量的最小斐波那契数。例如数组长度为 11，找到斐波那契数 13。
2. 用该斐波那契数的前两项分割数租。例如，`[0,10]` 的数组，用 13 的前两项 5 与 8，将其分为 5 个长度与 8 个长度的数组，根据实际情况调整为[0,4]与[5,10]。Mid 指针指向前一个数组的最后一位或者后一个数组的最前一位。
3. 使用二分查找相同的方法继续查找。

在实际算法实现中

```C
#include <stdlib.h>
#include <stdio.h>
int F[20];
int arr[20] = { 5,13,19,21,37,56,64,75,80,88,92};

void Fib_Matrix(){
	F[0] = 1;
	F[1] = 1;
	for (int i = 2; i < 20; i++) {
		F[i] = F[i - 1] + F[i - 2];
	}
	return;
}

int Fib_Next_Index(int key) {
	for (int i = 0; i < 20; i++) {
		if (key > F[i]) {
			continue;
		}
		return i;
	}
	return -1;
}

int Fib_Search(int key, int length) {
	int count = 0;
	int offset = -1;//相当于分割之前的起点
	int n = 11;
	n = Fib_Next_Index(n);//确定 比数组的长度大的 最小斐波那契数 在斐波那契数列中对应的 下标值 。
	int mid = offset + F[n - 2];//
	while (1) {
		if (key == arr[mid]) {
			return arr[mid];
		}
		else if (key > arr[mid]) {
			n -= 1;//更新下标，分割数组后，数组剩余大小等于斐波那契数列的前一项
			offset = mid;//将起点设置到当前mid点位置
			mid = offset + F[n - 2];//将mid点设置为数组的新起点下标+分割数组后，剩余数组的斐波那契分割点下标。
		}
		else {
			n -= 2;//更新下标，分割数组后，数组剩余大小等于斐波那契数列的前两项
			mid = offset + F[n - 2];//将mid点设置为数组的原先起点下标+分割数组后，剩余数组的斐波那契分割点下标。
		}
	}
}
int main() {
	Fib_Matrix();
	printf("%d",Fib_Search(80,11));
}


```

斐波那契查找不需要除法运算，在 CPU 的消耗上减少。所以斐波那契查找更适用于外存上的查找。
