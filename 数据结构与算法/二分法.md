# 查找两个有序数组中第 k 小的元素
## 实现逻辑
+ 每次查找时，排除 `k/2` 个元素，以此降低查找次数。
+ 将待查第 `k` 小数除以 `2`，即 `k/2` 查看两个数组中 ` k/2 ` 位置的元素，比较大小。数字大小较小的元素所在的数组记为 `array`，在 `array` 中，该元素左边所有元素都不可能是第 ` k ` 小元素，因此可直接排除。
+ 下次的排查，`array` 数组直接从 `k/2 + 1` 的位置开始排查，而另一个数组仍从起始位置排查。
+ 下次的排查，将 `k` 更新减去已排除数。


1. 初始化两个数组的起始指针 `as = 0, bs = 0`，循环直至：
	1. 任意一方的剩余数组长度为零，即 `as > a.size || bs > b.size` 则取另一个数组的剩余元素的第 ` k ` 个元素返回即可。
	2. `k == 1` 时，取两个数组当前起始位置中的元素数字大小较小的一个返回即可。
2. 更新两个数组的检查指针 `am = as + k/2 - 1` 以及 `bm = bs + k/2 - 1` 此时容易忽略 `-1`，因为第 `k` 小数在有序数组中为第 `k - 1` 位置的元素。
	1. 此时，如果有一方的判断指针位置要大于该数组的数组长度，即 `am > a.size || bm > b.size` 直接将判断指针的位置置于 ` arr.length - 1 ` 即可。
3. 比较大小，将较小元素所在的数组的起始位置更新为当前检查指针的后一位，即 `as = am + 1` 或者 `bs = bm + 1`，将 `k` 的剩余值更新为 `k-被排除数` ，即 ` k -= am - as + 1` 或者 ` k -= bm - bs + 1`，此时容易忽略 ` +1 `，因为排除了 `m 到 s` 的元素实际上排除了 `m - s + 1` 个元素。
4. 返回继续循环，直至循环结束，得到元素值。